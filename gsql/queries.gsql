USE GRAPH DocGraph

# ---- Document-level topK ----
CREATE QUERY TopKSimilarDocs(LIST<FLOAT> q, INT topk) FOR GRAPH DocGraph SYNTAX v2 {
  SumAccum<FLOAT> @dot; SumAccum<FLOAT> @norm; SumAccum<FLOAT> @qnorm;
  FLOAT qnorm = 0.0; INT n = q.size(); INT i = 0;
  while i < n do qnorm += q[i]*q[i]; i = i + 1; end; qnorm = sqrt(qnorm);

  Start = {Document.*};
  Start = SELECT d FROM Start:d POST-ACCUM
    d.@dot=0.0, d.@norm=0.0, d.@qnorm=qnorm,
    i=0, WHILE i<n DO
      CASE WHEN i<d.doc_embedding.size() THEN
        d.@dot += d.doc_embedding[i]*q[i];
        d.@norm += d.doc_embedding[i]*d.doc_embedding[i];
      END, i=i+1 END;
  Ranked = SELECT d FROM Start:d
    ACCUM d.@norm = sqrt(d.@norm)
    ORDER BY CASE WHEN (d.@norm*d.@qnorm)==0 THEN 0 ELSE (d.@dot/(d.@norm*d.@qnorm)) END DESC LIMIT topk;
  PRINT Ranked[Ranked.id AS id, Ranked.title AS title, Ranked.uri AS uri, Ranked.http_url AS http_url,
               (CASE WHEN (Ranked.@norm*Ranked.@qnorm)==0 THEN 0 ELSE (Ranked.@dot/(Ranked.@norm*Ranked.@qnorm)) END) AS score];
}

# ---- Page-level topK (aggregated per page) ----
CREATE QUERY TopKSimilarPages(LIST<FLOAT> q, INT topk) FOR GRAPH DocGraph SYNTAX v2 {
  SumAccum<FLOAT> @dot; SumAccum<FLOAT> @norm; SumAccum<FLOAT> @qnorm;
  FLOAT qnorm = 0.0; INT n = q.size(); INT i = 0;
  while i < n do qnorm += q[i]*q[i]; i = i + 1; end; qnorm = sqrt(qnorm);

  Start = {PageLevel.*};
  Start = SELECT p FROM Start:p POST-ACCUM
    p.@dot=0.0, p.@norm=0.0, p.@qnorm=qnorm,
    i=0, WHILE i<n DO
      CASE WHEN i<p.embedding.size() THEN
        p.@dot += p.embedding[i]*q[i];
        p.@norm += p.embedding[i]*p.embedding[i];
      END, i=i+1 END;

  Ranked = SELECT p FROM Start:p
    ACCUM p.@norm = sqrt(p.@norm)
    ORDER BY CASE WHEN (p.@norm*p.@qnorm)==0 THEN 0 ELSE (p.@dot/(p.@norm*p.@qnorm)) END DESC LIMIT topk;

  WITH Ranked AS R
  JoinDoc = SELECT R, D FROM R-(PAGELEVEL_OF)->Document:D
            ORDER BY (CASE WHEN (R.@norm*R.@qnorm)==0 THEN 0 ELSE (R.@dot/(R.@norm*R.@qnorm)) END) DESC
            LIMIT topk;

  PRINT JoinDoc[R.plid AS plid, R.doc_id AS doc_id, R.page_index AS page,
                D.title AS doc_title, D.uri AS uri, D.http_url AS http_url,
                (CASE WHEN (R.@norm*R.@qnorm)==0 THEN 0 ELSE (R.@dot/(R.@norm*R.@qnorm)) END) AS score];
}

# ---- Chunk-level topK ----
CREATE QUERY TopKSimilarChunks(LIST<FLOAT> q, INT topk) FOR GRAPH DocGraph SYNTAX v2 {
  SumAccum<FLOAT> @dot; SumAccum<FLOAT> @norm; SumAccum<FLOAT> @qnorm;
  FLOAT qnorm = 0.0; INT n = q.size(); INT i = 0;
  while i < n do qnorm += q[i]*q[i]; i = i + 1; end; qnorm = sqrt(qnorm);

  Start = {PageChunk.*};
  Start = SELECT c FROM Start:c POST-ACCUM
    c.@dot=0.0, c.@norm=0.0, c.@qnorm=qnorm,
    i=0, WHILE i<n DO
      CASE WHEN i<c.embedding.size() THEN
        c.@dot += c.embedding[i]*q[i];
        c.@norm += c.embedding[i]*c.embedding[i];
      END, i=i+1 END;

  Ranked = SELECT c FROM Start:c
    ACCUM c.@norm = sqrt(c.@norm)
    ORDER BY CASE WHEN (c.@norm*c.@qnorm)==0 THEN 0 ELSE (c.@dot/(c.@norm*c.@qnorm)) END DESC LIMIT topk;

  WITH Ranked AS R
  JoinDoc = SELECT R, P, D
            FROM R-(CHUNK_OF)->PageLevel:P-(PAGELEVEL_OF)->Document:D
            ORDER BY (CASE WHEN (R.@norm*R.@qnorm)==0 THEN 0 ELSE (R.@dot/(R.@norm*R.@qnorm)) END) DESC LIMIT topk;

  PRINT JoinDoc[R.pid AS pid, P.plid AS plid, R.doc_id AS doc_id, P.page_index AS page, R.chunk_index AS chunk,
                D.title AS doc_title, D.uri AS uri, D.http_url AS http_url,
                (CASE WHEN (R.@norm*R.@qnorm)==0 THEN 0 ELSE (R.@dot/(R.@norm*R.@qnorm)) END) AS score];
}

INSTALL QUERY TopKSimilarDocs
INSTALL QUERY TopKSimilarPages
INSTALL QUERY TopKSimilarChunks

